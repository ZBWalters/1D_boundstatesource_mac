#include "./classes.h"
#include "./globalbasis.h"

cmplx* globalbasis::psi0setup(cmplx (*func)(rl x)){
  //given some initial function, find coefficients for the spatial basis
  //functions so that psi0(x)=func(x)

  //number of equations will be equal to number of basis functions (recalling
  //that two adjacent elements share one basis function)
  int neq=nelts*xorder-(nelts-1);//also equal to (nelts-1)*xorder+1

  //evenly distribute the points where the function is to be evaluated among
  //the component elements
  int* npts=new int[nelts];
  for(int i=0;i<nelts;i++){
    npts[i]=xorder-1;
  }
  npts[nelts/2]+=1;// add an extra evaluation point near the center of the
		   // region of interest to yield the correct number of
		   // equations
  //set up array mapping the indices in a local element to the indices of the
  //global system.
  int* ptsfirstindices=new int[nelts];
  ptsfirstindices[0]=0;
  for(int i=1;i<nelts;i++){
    ptsfirstindices[i]=ptsfirstindices[i-1]+npts[i-1];
  }


  //set up arrays of integration points
  rl** fptarray=new rl*[nelts];
  for(int i=0;i<nelts;i++){
    //for each element, let the evaluation points be the points used for
    //gaussian integration of the appropriate order
    rl** inttable=elementbases[i]->integrationtable(npts[i]);
    fptarray[i]=inttable[0];
    delete [] inttable[1];
    delete [] inttable;
  }

  //set up the linear system to be solved to find the function coefficients:
  // \sum_{i} A_i X_{i}(x_{j})=f(x_{j}) \forall x_{j}
  cmplx* __restrict rhsvec=initializearray(neq);
  int ku=xorder;
  int kl=xorder;
  int ldab=2*kl+ku+1;
  int width=2*kl+ku+1;
  cmplx* __restrict lhsmat=initializearray(width*neq);
  for(int eltnum=0;eltnum<nelts;eltnum++){
    for(int i=0;i<npts[eltnum];i++){
      //rhs is value of func at the chosen point
      int ptindx=ptsfirstindices[eltnum]+i;
      rl x=fptarray[eltnum][i];
      rhsvec[ptindx]=func(x);
      
      //lhs is value of basis functions at the chosen point
      cmplx* bfvals=elementbases[eltnum]->evalbasisfuncs(x);
      for(int j=0;j<xorder;j++){
	int bfindx=eltfirstindices[eltnum]+j;
	lhsmat[bandarrayindx(bfindx,ptindx,ku,kl,neq)]=bfvals[j];
      }
      delete [] bfvals;
    }
  }

  //call zgbsv to solve for psi0
  int nrhs=1;
  int* ipiv=new int[neq];
  int info=0;
  zgbsv(&neq,&kl,&ku,&nrhs,lhsmat,&ldab,ipiv,rhsvec,&neq,&info);
  if(info!=0){
    cout << "problem with zgbsv in psi0setup! "<<info<<"\n";
  }

  delete [] lhsmat;
  delete [] ipiv;
  delete [] npts;
  delete [] ptsfirstindices;
  for(int i=0;i<nelts;i++){
    delete [] fptarray[i];
  }
  delete [] fptarray;

  return rhsvec;
}
